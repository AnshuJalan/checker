
* We seriously have to check that the values do not drift too far away and all
  other functionality-related things we have left TODOs for (and ones that we
  have left no TODOs for).

* Explicit [@@inline] markers/statements on the numeric operations. We'll see
  what to do at the end, but best to explicitly mark them.

* Do not divide by scaling factor and then multiply by it when going from
  tez/kit to/from ratio. NOTE that this breaks the calculations initially; we
  gotta fix that. This seems to be a bit of a pain though: in some cases it
  doesn't matter whether we are dealing with mutez or tez (as long as we do so
  consistently), but in others it does. Think about this.

* What about the errors? We certainly don't want an open union type, but we
  also don't want the `result` type I think; if things go south we want
  execution to fail. My approach here would be either using `failwith` or
  `raise`; we could then at the end convert all `raise` statements into LIGO's
  `failwith`s automatically.

* Locally opening modules (and/or using user-defined operators) also is a
  problem; perhaps we should just turn all operators into simple functions and
  not open anything locally. Otherwise, the transformation from OCaml to LIGO
  will have to be scope-aware, to decide what should each operator translate
  to. For things like Nat, Int, and Tez it should be OK, but for Ratio it
  isn't.


* [done] Z.divexact   ===> Use Z.(/) instead

* [    ] Z.gcd

* [    ] Z.cdiv
* [    ] Z.cdiv
* [    ] Z.cdiv

* [    ] Z.fdiv       ===> In Nat use Z.ediv_rem and drop the remainder.
* [    ] Z.fdiv       ===> In Nat use Z.ediv_rem and drop the remainder.
* [    ] Z.fdiv       ===> In Nat use Z.ediv_rem and drop the remainder.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Separate int and nat. Use separate definitions within the OCaml codebase so
  that they are perfecty mapped to LIGO types. In fact, just add Nat.t, because
  Z.t should be enough for LIGO's int.

* Explicit definition for Q.t; call it Rational.t? Only the operations that we
  really need. This should be a tuple (numerator, denominator).

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Burrow Contract vs. Checker Contract
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
QQ: So, how do we REALLY represent the checker contract and the burrow
contracts?

  I am pretty sure that we cannot keep a map from burrow_id (which should be a
tezos address, really) inside the storage of the checker contract, because its
size would be potentially massive (burrows never close, not really).

QQ: Shall I write up a quick mock chain implementation?

  To be able to test the feasibility of everything we are doing, I'd like to
have it. Basically it would keep the map from burrow addresses to the burrows,
instead of being inside checker. I think that this is much more honest than
what we have right now, where we do back and forths, which are practically
infeasible.
  Perhaps We should restructure the code and push all kind of work that needs
access to the burrow state into a single call. This means quite some work
really happening on the burrow side.


* Decide what the initial set of parameters should be.
* Shall we store 1/q instead of q? Is it really that important/does it even make a difference?
* Inline all numeric operations, flatten all Q.t (deal with integers only).
* Hardwire all the constants.







*
