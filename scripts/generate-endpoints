#!/usr/bin/env ruby

EndpointInfo = Struct.new(:name, :param_sig)

endpoints = []
ARGF.each_line do |line|
   case line
   when /^val +endpoint_(\S+).*checker\s+\*\s+(.*?)\s+->/ then endpoints << EndpointInfo.new( $1, $2)
   when /^val +endpoint_/ then raise "#{ARGF.filename}:#{ARGF.lineno}: Unrecognised endpoint decl #{line}"
   end
end

class String
  def camelize
    split(/_/).map(&:capitalize).join
  end
end

puts <<EOF
(* GENERATED BY generate-endpoints SCRIPT, DO NOT EDIT BY HAND *)

open CheckerTypes
open Checker

EOF

puts "type lazy_function_id = Ligo.int"
puts
endpoints.each.with_index do |e, n|
  puts "let[@inline] lazy_id_#{e.name} = Ligo.int_from_literal \"#{n}\""
end
puts

puts "type lazy_function = checker * Ligo.bytes -> LigoOp.operation list * checker"
puts
puts "let checkerParamsToLazyFunctionId (p: checker_params) : lazy_function_id * Ligo.bytes =
  match p with
"
endpoints.each do |e|
  puts "   | #{e.name.camelize} a -> (lazy_id_#{e.name}, Ligo.Bytes.pack (deticketify_#{e.name} a))"
end

# Generate wrappers for endpoint functions
endpoints.each do |endpoint|
  puts "
(* BEGIN_LIGO
let lazy_fun_#{endpoint.name} (checker, params: checker * Ligo.bytes): LigoOp.operation list * checker =
  match (Ligo.Bytes.unpack params: #{endpoint.param_sig} option) with
  | Some p -> endpoint_#{endpoint.name} (checker, p)
  | None -> (failwith \"unexpected params\": LigoOp.operation list * checker)
END_LIGO *)
"
end
puts

# Generate an ocaml shim to avoid packing
puts "(* BEGIN_OCAML *)"
puts "let runCheckerParams (params: checker_params) (checker: checker): LigoOp.operation list * checker =
  match params with
"
endpoints.each do |e|
  puts "   | #{e.name.camelize} a -> endpoint_#{e.name} (checker, deticketify_#{e.name} a)"
end
puts "(* END_OCAML *)"
