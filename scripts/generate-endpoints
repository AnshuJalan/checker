#!/usr/bin/env ruby

EndpointInfo = Struct.new(:name, :param_sig)

endpoints = []
ARGF.each_line do |line|
   case line
   when /^val +endpoint_(\S+).*checker\s+\*\s+(.*?)\s+->/ then endpoints << EndpointInfo.new( $1, $2)
   when /^val +endpoint_/ then raise "#{ARGF.filename}:#{ARGF.lineno}: Unrecognised endpoint decl #{line}"
   end
end

class String
  def camelize
    split(/_/).map(&:capitalize).join
  end
end

puts <<EOF
(* GENERATED BY generate-endpoints SCRIPT, DO NOT EDIT BY HAND *)

open Kit
open LiquidationAuctionPrimitiveTypes
open Tickets
open CheckerTypes
open Checker

EOF

puts "type params = \n   " +
     endpoints.map { |e| "#{e.name.camelize} of #{e.param_sig}" }.join("\n | ")

puts
puts "type lazyFunctionId = Ligo.int"
puts
puts "let paramsToLazyFunctionId (p: params) : lazyFunctionId * params =
  match p with
"
# Need to rebind the constructor arg to work around linearity of tickets
endpoints.each.with_index do |e, n|
  puts "   | #{e.name.camelize} a -> (Ligo.int_from_literal \"#{n}\", #{e.name.camelize} a)"
end

# Generate wrappers for endpoint functions

endpoints.each do |endpoint|
  puts "
let lazy_fun_#{endpoint.name} (checker, params: checker * params): LigoOp.operation list * checker =
  let p = match params with
    | #{endpoint.name.camelize} a -> a
"
  (endpoints - [endpoint]).each do |other|
  puts "    | #{other.name.camelize} _ -> (failwith \"unexpected params\": #{endpoint.param_sig})"
  end
  puts "  in endpoint_#{endpoint.name} (checker, p)"
end
